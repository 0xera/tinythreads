#ifdef __PIC32M__
#include <priv/tth_core.h>
#include <stdint.h>
#include <sys/attribs.h>

#if (TTHREAD_ENABLE_SRS)
uint16_t tth_pic32m_srs = 3;
#endif
#if (TTHREAD_FPU_DELAYED_IN_ISR) || (TTHREAD_DSP_DELAYED_IN_ISR)
void *tth_pic32m_isr_ctx[TTHREAD_MAX_IPL_COUNT];
#endif
#if (TTHREAD_FPU_DELAYED_SWITCH)
void *tth_pic32m_fpu_ctx;
#endif
#if (TTHREAD_DSP_DELAYED_SWITCH)
void *tth_pic32m_dsp_ctx;
#endif

#if (TTHREAD_ENABLE_SRS)
/*
 * Allocate free shadow register set
 */
void tth_pic32m_alloc_srs(tth_thread *thread)
{
  int lock = tth_arch_cs_begin();
  uint16_t bits = ~tth_pic32m_srs;
  int srs;

  /* Search first zero from LSB */
  bits = (bits & (-bits)) - 1;
  bits = (bits & 0x5555u) + ((bits >> 1) & 0x5555u);
  bits = (bits & 0x3333u) + ((bits >> 2) & 0x3333u);
  bits = (bits & 0x0707u) + ((bits >> 4) & 0x0707u);
  srs  = (bits & 0x000fu) + ((bits >> 8) & 0x000fu);

  if (srs > ((_CP0_GET_SRSCTL() & _CP0_SRSCTL_HSS_MASK) >> _CP0_SRSCTL_HSS_POSITION))
  {
    srs = 0;
  }
  else
  {
    tth_pic32m_srs |= (1u << srs);
  }

  tth_arch_cs_end(lock);
  thread->arch.srs = srs;
  return srs;
}
#endif

void tth_arch_cs_cleanup(tth_thread *thread)
{
#if (TTHREAD_ENABLE_SRS)
  int srs = thread->arch.srs;
  if (srs > 0)
  {
    tth_pic32m_srs &= ~(1u << srs);
  }
#endif  /* TTHREAD_ENABLE_SRS */
}

#ifdef TTHREAD_TIMER_IRQ
typedef struct {
  uint32_t reg;
  uint32_t clr;
  uint32_t set;
  uint32_t inv;
} sfr_reg_t;

# define _CP0_TIMER_PERIOD \
  ((1ull * TTHREAD_TIMER_RESOLUTION_US * TTHREAD_TIMER_CLOCK_HZ + 999999) / 1000000)

void tth_arch_init_timer(void)
{
  /* Configure interrupt controller */
  ((sfr_reg_t *)&IEC0)[TTHREAD_TIMER_IRQ >> 5].clr = (1u << (TTHREAD_TIMER_IRQ & 31));
  ((sfr_reg_t *)&IFS0)[TTHREAD_TIMER_IRQ >> 5].clr = (1u << (TTHREAD_TIMER_IRQ & 31));
  ((sfr_reg_t *)&IPC0)[TTHREAD_TIMER_IRQ >> 2].clr = (0xffu << ((TTHREAD_TIMER_IRQ & 3) * 8));
  ((sfr_reg_t *)&IPC0)[TTHREAD_TIMER_IRQ >> 2].set =
    (((TTHREAD_TIMER_IPL << 2) | (TTHREAD_TIMER_SUB_IPL)) << ((TTHREAD_TIMER_IRQ & 3) * 8));

#if (TTHREAD_TIMER_PERIPHERAL_ID == 0)
  /* Core Timer (CP0) */
# if (_CP0_TIMER_PERIOD < 0x80000000ull)
  _CP0_SET_CAUSE(_CP0_GET_CAUSE() | _CP0_CAUSE_DC_MASK);      /* Stop counter */
  _ehb();
  _CP0_SET_COUNT(0);                                          /* Clear counter */
  _CP0_SET_COMPARE(_CP0_TIMER_PERIOD);                        /* Set next compare */
  _CP0_SET_DEBUG(_CP0_GET_DEBUG() | _CP0_DEBUG_COUNTDM_MASK); /* Run also in debug mode */
  _ehb();
  _CP0_SET_CAUSE(_CP0_GET_CAUSE() & ~_CP0_CAUSE_DC_MASK);     /* Start counter */
  _ehb();
# else
#  error "[TinyThreads] Timer resolution is too large to be generated by Core Timer!"
# endif
#else   /* TTHREAD_TIMER_PERIPHERAL_ID > 0 */
  /* Peripheral Timer (Timer N) */
  TTHREAD_TIMER_REG_TXCONbits_t bits = { 0 };
  bits.ON = 1;
# define _PERIOD(pres)  \
  ((1ull * TTHREAD_TIMER_RESOLUTION_US * TTHREAD_TIMER_CLOCK_HZ + (1000000 * pres) - 1) / \
    (1000000 * pres))
# if (_PERIOD(TTHREAD_TIMER_PRESCALER0) <= 65536)
  bits.TCKPS = 0;
  TTHREAD_TIMER_REG_PRX = _PERIOD(TTHREAD_TIMER_PRESCALER0) - 1;
# elif (_PERIOD(TTHREAD_TIMER_PRESCALER1) <= 65536)
  bits.TCKPS = 1;
  TTHREAD_TIMER_REG_PRX = _PERIOD(TTHREAD_TIMER_PRESCALER1) - 1;
# elif (_PERIOD(TTHREAD_TIMER_PRESCALER2) <= 65536)
  bits.TCKPS = 2;
  TTHREAD_TIMER_REG_PRX = _PERIOD(TTHREAD_TIMER_PRESCALER2) - 1;
# elif (_PERIOD(TTHREAD_TIMER_PRESCALER3) <= 65536)
  bits.TCKPS = 3;
  TTHREAD_TIMER_REG_PRX = _PERIOD(TTHREAD_TIMER_PRESCALER3) - 1;
# elif (_PERIOD(TTHREAD_TIMER_PRESCALER4) <= 65536)
  bits.TCKPS = 4;
  TTHREAD_TIMER_REG_PRX = _PERIOD(TTHREAD_TIMER_PRESCALER4) - 1;
# elif (_PERIOD(TTHREAD_TIMER_PRESCALER5) <= 65536)
  bits.TCKPS = 5;
  TTHREAD_TIMER_REG_PRX = _PERIOD(TTHREAD_TIMER_PRESCALER5) - 1;
# elif (_PERIOD(TTHREAD_TIMER_PRESCALER6) <= 65536)
  bits.TCKPS = 6;
  TTHREAD_TIMER_REG_PRX = _PERIOD(TTHREAD_TIMER_PRESCALER6) - 1;
# elif (_PERIOD(TTHREAD_TIMER_PRESCALER7) <= 65536)
  bits.TCKPS = 7;
  TTHREAD_TIMER_REG_PRX = _PERIOD(TTHREAD_TIMER_PRESCALER7) - 1;
# else
#  error "[TinyThreads] Timer resolution is too large to be generated by specified Timer Peripheral!"
# endif
# undef _PERIOD
  TTHREAD_TIMER_REG_TMRX = 0;
  /* Configure & Start timer */
  TTHREAD_TIMER_REG_TXCONbits.w = bits.w;
#endif  /* TTHREAD_TIMER_PERIPHERAL_ID > 0 */

  /* Enable interrupt */
  ((sfr_reg_t *)&IEC0)[TTHREAD_TIMER_IRQ >> 5].set = (1u << (TTHREAD_TIMER_IRQ & 31));
}

void __ISR(TTHREAD_TIMER_IRQ, TTHREAD_TIMER_IPL_ID) _TTHREAD_TICK_ISR()
{
  /* Clear interrupt */
  ((sfr_reg_t *)&IFS0)[TTHREAD_TIMER_IRQ >> 5].clr = (1u << (TTHREAD_TIMER_IRQ & 31));

#if (TTHREAD_TIMER_PERIPHERAL_ID == 0)
  /* Update Core Timer next compare */
  uint32_t count0 = _CP0_GET_COUNT();
  uint32_t compare0 = _CP0_GET_COMPARE();
  uint32_t compare1 = compare0 + _CP0_TIMER_PERIOD;

  if (((compare0 < compare1) && ((compare0 <= count0) && (count0 < compare1))) ||
      ((compare0 > compare1) && ((compare0 <= count0) || (count0 < compare1)))) {
    _CP0_SET_COMPARE(compare1);

    uint32_t count1 = _CP0_GET_COUNT();
    if (((compare0 < compare1) && ((compare0 <= count1) && (count1 < compare1))) ||
        ((compare0 > compare1) && ((compare0 <= count1) || (count1 < compare1)))) {
      goto update_finish;
    }
  }
  int lock = tth_arch_cs_begin();
  /* Count has overrun during Compare update */
  _CP0_SET_COMPARE(_CP0_GET_COUNT() + 8);
  tth_arch_cs_end(lock);
update_finish:
#endif
  tth_int_tick();
}
#endif  /* defined(TTHREAD_TIMER_IRQ) */

#endif  /* __PIC32M__ */
